import { defineCustomElements } from '@ionic/core/loader';
import React, { useContext } from 'react';
import { __rest } from 'tslib';
import ReactDom from 'react-dom';
import { NavContext, IonLifeCycleContext } from '@ionic/react-core';
import { isPlatform, getPlatforms, alertController, loadingController, toastController, actionSheetController, modalController, popoverController } from '@ionic/core';
import { addIcons } from 'ionicons';
import { close, reorder, menu, arrowForward, arrowBack, arrowDown, search, closeCircle } from 'ionicons/icons';

function attachEventProps(node, newProps, oldProps = {}) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className) {
        node.className = className;
    }
    Object.keys(newProps).forEach(name => {
        if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {
            return;
        }
        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
            const eventName = name.substring(2);
            const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
            if (!isCoveredByReact(eventNameLc)) {
                syncEvent(node, eventNameLc, newProps[name]);
            }
        }
        else {
            node[name] = newProps[name];
        }
    });
}
function getClassName(classList, newProps, oldProps) {
    // map the classes to Maps for performance
    const currentClasses = arrayToMap(classList);
    const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);
    const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);
    const finalClassNames = [];
    // loop through each of the current classes on the component
    // to see if it should be a part of the classNames added
    currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
            // add it as its already included in classnames coming in from newProps
            finalClassNames.push(currentClass);
            incomingPropClasses.delete(currentClass);
        }
        else if (!oldPropClasses.has(currentClass)) {
            // add it as it has NOT been removed by user
            finalClassNames.push(currentClass);
        }
    });
    incomingPropClasses.forEach(s => finalClassNames.push(s));
    return finalClassNames.join(' ');
}
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isCoveredByReact(eventNameSuffix, doc = document) {
    const eventName = 'on' + eventNameSuffix;
    let isSupported = eventName in doc;
    if (!isSupported) {
        const element = doc.createElement('div');
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] === 'function';
    }
    return isSupported;
}
function syncEvent(node, eventName, newEventHandler) {
    const eventStore = node.__events || (node.__events = {});
    const oldEventHandler = eventStore[eventName];
    // Remove old listener so they don't double up.
    if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
    }
    // Bind new listener.
    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
        newEventHandler.call(this, e);
    });
}
function arrayToMap(arr) {
    const map = new Map();
    arr.forEach((s) => map.set(s, s));
    return map;
}

const IonicContext = /*@__PURE__*/ React.createContext({
    getConfig: () => { },
    setConfig: () => { },
    platform: undefined
});

const useIonicConfig = () => {
    const value = React.useContext(IonicContext);
    const config = value.getConfig() || {};
    const hook = [config, value.setConfig];
    return hook;
};

const dashToPascalCase = (str) => str.toLowerCase().split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
function generateUniqueId() {
    return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {
        const random = crypto.getRandomValues(new Uint8Array(1));
        return (c ^ random[0] & 15 >> c / 4).toString(16);
    });
}

function createReactComponent(tagName, attributeValues = [], hrefComponent = false) {
    const displayName = dashToPascalCase(tagName);
    class ReactComponent extends React.Component {
        constructor(props) {
            super(props);
            this.handleClick = this.handleClick.bind(this);
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            this.componentWillReceiveProps(this.props);
        }
        componentWillReceiveProps(props) {
            const node = ReactDom.findDOMNode(this);
            attachEventProps(node, props, this.props);
        }
        handleClick(e) {
            const { href, target, routerDirection } = this.props;
            if ((href && this.context.hasIonicRouter()) && !target) {
                e.preventDefault();
                this.context.navigate(href, routerDirection);
            }
        }
        render() {
            const _a = this.props, { children, forwardedRef } = _a, cProps = __rest(_a, ["children", "forwardedRef"]);
            const propsWithoutAttributeValues = Object.keys(cProps).reduce((oldValue, key) => {
                if (attributeValues.indexOf(key) === -1) {
                    oldValue[key] = cProps[key];
                }
                return oldValue;
            }, {});
            const newProps = Object.assign({}, propsWithoutAttributeValues, { ref: forwardedRef });
            if (hrefComponent) {
                if (newProps.onClick) {
                    const oldClick = newProps.onClick;
                    newProps.onClick = (e) => {
                        oldClick(e);
                        if (!e.defaultPrevented) {
                            this.handleClick(e);
                        }
                    };
                }
                else {
                    newProps.onClick = this.handleClick;
                }
            }
            return React.createElement(tagName, newProps, children);
        }
    }
    ReactComponent.contextType = NavContext;
    function forwardRef(props, ref) {
        return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    }
    forwardRef.displayName = displayName;
    return React.forwardRef(forwardRef);
}

// /*@__PURE__*/createReactComponent
const IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar');
const IonBackButtonInner = /*@__PURE__*/ createReactComponent('ion-back-button');
const IonAppInner = /*@__PURE__*/ createReactComponent('ion-app');

class Platform {
    constructor() { }
    /**
     * @returns returns true/false based on platform.
     * @description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.                      |
     * | mobile          | on a mobile device.                |
     * | mobileweb       | on a mobile device in a browser.   |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     */
    is(platformName) {
        return isPlatform(window, platformName);
    }
    /**
     * @returns the array of platforms
     * @description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     */
    platforms() {
        return getPlatforms(window);
    }
    /**
   * Returns if this app is using right-to-left language direction or not.
   * We recommend the app's `index.html` file already has the correct `dir`
   * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
   * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
   */
    get isRTL() {
        return document.dir === 'rtl';
    }
    /**
   * Get the query string parameter
   */
    getQueryParam(key) {
        return readQueryParam(window.location.href, key);
    }
    /**
     * Returns `true` if the app is in landscape mode.
     */
    isLandscape() {
        return !this.isPortrait();
    }
    /**
    * Returns `true` if the app is in portait mode.
    */
    isPortrait() {
        return window.matchMedia && window.matchMedia('(orientation: portrait)').matches;
    }
    testUserAgent(expression) {
        const nav = window.navigator;
        return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);
    }
    /**
   * Get the current url.
   */
    url() {
        return window.location.href;
    }
    /**
     * Gets the width of the platform's viewport using `window.innerWidth`.
     */
    width() {
        return window.innerWidth;
    }
    /**
     * Gets the height of the platform's viewport using `window.innerHeight`.
     */
    height() {
        return window.innerHeight;
    }
}
const readQueryParam = (url, key) => {
    key = key.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + key + '=([^&#]*)');
    const results = regex.exec(url);
    return results ? decodeURIComponent(results[1].replace(/\+/g, ' ')) : null;
};

function getConfig() {
    const coreConfig = getCoreConfig();
    const config = Array.from(coreConfig.m).reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
    }, {});
    return config;
}
function setConfig(config) {
    const coreConfig = getCoreConfig();
    coreConfig.reset(config);
}
function getCoreConfig() {
    if (typeof window !== 'undefined') {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
            return window.Ionic.config;
        }
    }
    return null;
}

class IonApp extends React.Component {
    constructor(props) {
        super(props);
        const ionicPlatform = new Platform();
        this.state = {
            getConfig: getConfig,
            setConfig: setConfig,
            platform: ionicPlatform
        };
    }
    render() {
        return (React.createElement(IonicContext.Provider, { value: this.state },
            React.createElement(IonAppInner, null, this.props.children)));
    }
}

// ionicons
const IonIcon = /*@__PURE__*/ createReactComponent('ion-icon', ['icon']);
// /*@__PURE__*/createReactComponent
const IonTab = /*@__PURE__*/ createReactComponent('ion-tab');
const IonTabButton = /*@__PURE__*/ createReactComponent('ion-tab-button');
const IonRouterLink = /*@__PURE__*/ createReactComponent('ion-router-link', [], true);
const IonAvatar = /*@__PURE__*/ createReactComponent('ion-avatar');
const IonBackdrop = /*@__PURE__*/ createReactComponent('ion-backdrop');
const IonBadge = /*@__PURE__*/ createReactComponent('ion-badge');
const IonButton = /*@__PURE__*/ createReactComponent('ion-button', [], true);
const IonButtons = /*@__PURE__*/ createReactComponent('ion-buttons');
const IonCard = /*@__PURE__*/ createReactComponent('ion-card', [], true);
const IonCardContent = /*@__PURE__*/ createReactComponent('ion-card-content');
const IonCardHeader = /*@__PURE__*/ createReactComponent('ion-card-header');
const IonCardSubtitle = /*@__PURE__*/ createReactComponent('ion-card-subtitle');
const IonCardTitle = /*@__PURE__*/ createReactComponent('ion-card-title');
const IonCheckbox = /*@__PURE__*/ createReactComponent('ion-checkbox');
const IonCol = /*@__PURE__*/ createReactComponent('ion-col');
const IonContent = /*@__PURE__*/ createReactComponent('ion-content');
const IonChip = /*@__PURE__*/ createReactComponent('ion-chip');
const IonDatetime = /*@__PURE__*/ createReactComponent('ion-datetime');
const IonFab = /*@__PURE__*/ createReactComponent('ion-fab');
const IonFabButton = /*@__PURE__*/ createReactComponent('ion-fab-button', [], true);
const IonFabList = /*@__PURE__*/ createReactComponent('ion-fab-list');
const IonFooter = /*@__PURE__*/ createReactComponent('ion-footer');
const IonGrid = /*@__PURE__*/ createReactComponent('ion-grid');
const IonHeader = /*@__PURE__*/ createReactComponent('ion-header');
const IonImg = /*@__PURE__*/ createReactComponent('ion-img');
const IonInfiniteScroll = /*@__PURE__*/ createReactComponent('ion-infinite-scroll');
const IonInput = /*@__PURE__*/ createReactComponent('ion-input');
const IonItem = /*@__PURE__*/ createReactComponent('ion-item', [], true);
const IonItemDivider = /*@__PURE__*/ createReactComponent('ion-item-divider');
const IonItemGroup = /*@__PURE__*/ createReactComponent('ion-item-group');
const IonItemOption = /*@__PURE__*/ createReactComponent('ion-item-option', [], true);
const IonItemOptions = /*@__PURE__*/ createReactComponent('ion-item-options');
const IonItemSliding = /*@__PURE__*/ createReactComponent('ion-item-sliding');
const IonLabel = /*@__PURE__*/ createReactComponent('ion-label');
const IonList = /*@__PURE__*/ createReactComponent('ion-list');
const IonListHeader = /*@__PURE__*/ createReactComponent('ion-list-header');
const IonMenu = /*@__PURE__*/ createReactComponent('ion-menu');
const IonMenuButton = /*@__PURE__*/ createReactComponent('ion-menu-button');
const IonMenuToggle = /*@__PURE__*/ createReactComponent('ion-menu-toggle');
const IonNote = /*@__PURE__*/ createReactComponent('ion-note');
const IonPicker = /*@__PURE__*/ createReactComponent('ion-picker');
const IonPickerColumn = /*@__PURE__*/ createReactComponent('ion-picker-column');
const IonNav = /*@__PURE__*/ createReactComponent('ion-nav');
const IonProgressBar = /*@__PURE__*/ createReactComponent('ion-progress-bar');
const IonRadio = /*@__PURE__*/ createReactComponent('ion-radio');
const IonRadioGroup = /*@__PURE__*/ createReactComponent('ion-radio-group');
const IonRange = /*@__PURE__*/ createReactComponent('ion-range');
const IonRefresher = /*@__PURE__*/ createReactComponent('ion-refresher');
const IonRefresherContent = /*@__PURE__*/ createReactComponent('ion-refresher-content');
const IonReorder = /*@__PURE__*/ createReactComponent('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ createReactComponent('ion-reorder-group');
const IonRippleEffect = /*@__PURE__*/ createReactComponent('ion-ripple-effect');
const IonRouterOutlet = /*@__PURE__*/ createReactComponent('ion-router-outlet');
const IonRow = /*@__PURE__*/ createReactComponent('ion-row');
const IonSearchbar = /*@__PURE__*/ createReactComponent('ion-searchbar');
const IonSegment = /*@__PURE__*/ createReactComponent('ion-segment');
const IonSegmentButton = /*@__PURE__*/ createReactComponent('ion-segment-button');
const IonSelect = /*@__PURE__*/ createReactComponent('ion-select');
const IonSelectOption = /*@__PURE__*/ createReactComponent('ion-select-option');
const IonSelectPopover = /*@__PURE__*/ createReactComponent('ion-select-popover');
const IonSkeletonText = /*@__PURE__*/ createReactComponent('ion-skeleton-text');
const IonSlide = /*@__PURE__*/ createReactComponent('ion-slide');
const IonSlides = /*@__PURE__*/ createReactComponent('ion-slides');
const IonSpinner = /*@__PURE__*/ createReactComponent('ion-spinner');
const IonSplitPane = /*@__PURE__*/ createReactComponent('ion-split-pane');
const IonText = /*@__PURE__*/ createReactComponent('ion-text');
const IonTextarea = /*@__PURE__*/ createReactComponent('ion-textarea');
const IonThumbnail = /*@__PURE__*/ createReactComponent('ion-thumbnail');
const IonTitle = /*@__PURE__*/ createReactComponent('ion-title');
const IonToggle = /*@__PURE__*/ createReactComponent('ion-toggle');
const IonToolbar = /*@__PURE__*/ createReactComponent('ion-toolbar');
const IonVirtualScroll = /*@__PURE__*/ createReactComponent('ion-virtual-scroll');

function createControllerComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactControllerComponent extends React.Component {
        constructor(props) {
            super(props);
            this.id = generateUniqueId();
        }
        static get displayName() {
            return displayName;
        }
        async componentDidMount() {
            const { isOpen } = this.props;
            if (isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { isOpen, onDidDismiss } = _a, cProps = __rest(_a, ["isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return null;
        }
    };
}

const IonAlert = /*@__PURE__*/ createControllerComponent('IonAlert', alertController);

const IonLoading = /*@__PURE__*/ createControllerComponent('IonLoading', loadingController);

const IonToast = /*@__PURE__*/ createControllerComponent('IonToast', toastController);

function createOverlayComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactOverlayComponent extends React.Component {
        constructor(props) {
            super(props);
            this.el = document.createElement('div');
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            if (this.props.isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { children, isOpen, onDidDismiss = () => { } } = _a, cProps = __rest(_a, ["children", "isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps, { component: this.el, componentProps: {} }));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return ReactDom.createPortal(this.props.children, this.el);
        }
    };
}

const IonActionSheet = /*@__PURE__*/ createOverlayComponent('IonActionSheet', actionSheetController);

const IonModal = /*@__PURE__*/ createOverlayComponent('IonModal', modalController);

const IonPopover = /*@__PURE__*/ createOverlayComponent('IonPopover', popoverController);

const IonPageInternal = (_a) => {
    var { children, forwardedRef, className } = _a, props = __rest(_a, ["children", "forwardedRef", "className"]);
    return (React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));
};
function forwardRef(props, ref) {
    return React.createElement(IonPageInternal, Object.assign({}, props, { forwardedRef: ref }));
}
forwardRef.displayName = 'IonPage';
const IonPage = /*@__PURE__*/ React.forwardRef(forwardRef);

class IonTabBarUnwrapped extends React.Component {
    constructor(props) {
        super(props);
        this.onTabButtonClick = (e) => {
            const targetUrl = (this.state.activeTab === e.detail.tab) ?
                this.state.tabs[e.detail.tab].originalHref :
                this.state.tabs[e.detail.tab].currentHref;
            this.props.navigate(targetUrl);
        };
        this.renderChild = (activeTab) => (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                const href = (child.props.tab === activeTab) ? this.props.currentPath : (this.state.tabs[child.props.tab].currentHref);
                return React.cloneElement(child, {
                    href,
                    onIonTabButtonClick: this.onTabButtonClick
                });
            }
            return null;
        };
        const tabActiveUrls = {};
        React.Children.forEach(this.props.children, (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                tabActiveUrls[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href
                };
            }
        });
        this.state = {
            activeTab: null,
            tabs: tabActiveUrls
        };
    }
    static getDerivedStateFromProps(props, state) {
        const activeTab = Object.keys(state.tabs)
            .find(key => {
            const href = state.tabs[key].originalHref;
            return props.currentPath.startsWith(href);
        });
        if (!activeTab || (activeTab === state.activeTab && state.tabs[activeTab].currentHref === props.currentPath)) {
            return null;
        }
        return {
            activeTab,
            tabs: Object.assign({}, state.tabs, { [activeTab]: {
                    originalHref: state.tabs[activeTab].originalHref,
                    currentHref: props.currentPath
                } })
        };
    }
    render() {
        return (React.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: this.state.activeTab }), React.Children.map(this.props.children, this.renderChild(this.state.activeTab))));
    }
}
const IonTabBar = (props) => {
    const context = useContext(NavContext);
    return (React.createElement(IonTabBarUnwrapped, Object.assign({}, props, { navigate: (path) => {
            context.navigate(path);
        }, currentPath: context.currentPath }), props.children));
};

const hostStyles = {
    display: 'flex',
    position: 'absolute',
    top: '0',
    left: '0',
    right: '0',
    bottom: '0',
    flexDirection: 'column',
    width: '100%',
    height: '100%',
    contain: 'layout size style'
};
const tabsInner = {
    position: 'relative',
    flex: 1,
    contain: 'layout size style'
};
class IonTabs extends React.Component {
    constructor(props) {
        super(props);
        this.routerOutletRef = React.createRef();
    }
    render() {
        let outlet;
        let tabBar;
        React.Children.forEach(this.props.children, (child) => {
            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {
                return;
            }
            if (child.type === IonRouterOutlet) {
                outlet = child;
            }
            if (child.type === IonTabBar) {
                tabBar = child;
            }
        });
        if (!outlet) {
            throw new Error('IonTabs must contain an IonRouterOutlet');
        }
        const NavManager = this.context.getViewManager();
        return (React.createElement("div", { style: hostStyles },
            tabBar.props.slot === 'top' ? tabBar : null,
            React.createElement("div", { style: tabsInner, className: "tabs-inner" }, this.context.hasIonicRouter() ? (React.createElement(NavManager, null, outlet)) : (React.createElement(React.Fragment, null, outlet))),
            tabBar.props.slot === 'bottom' ? tabBar : null));
    }
}
IonTabs.contextType = NavContext;

class IonBackButton extends React.Component {
    constructor() {
        super(...arguments);
        this.clickButton = (e) => {
            if (this.context.hasIonicRouter()) {
                e.stopPropagation();
                this.context.goBack(this.props.defaultHref);
            }
            else {
                window.location.href = this.props.defaultHref;
            }
        };
    }
    render() {
        return (React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props)));
    }
}
IonBackButton.contextType = NavContext;

defineCustomElements(window);
// Icons that are used by internal components
addIcons({
    'ios-close': close.ios,
    'md-close': close.md,
    'ios-reorder': reorder.ios,
    'md-reorder': reorder.md,
    'ios-menu': menu.ios,
    'md-menu': menu.md,
    'ios-arrow-forward': arrowForward.ios,
    'md-arrow-forward': arrowForward.md,
    'ios-arrow-back': arrowBack.ios,
    'md-arrow-back': arrowBack.md,
    'ios-arrow-down': arrowDown.ios,
    'md-arrow-down': arrowDown.md,
    'ios-search': search.ios,
    'md-search': search.md,
    'ios-close-circle': closeCircle.ios,
    'md-close-circle': closeCircle.md,
});

const withIonLifeCycle = (WrappedComponent) => {
    return class IonLifeCycle extends React.Component {
        constructor(props) {
            super(props);
            this.componentRef = React.createRef();
        }
        componentDidMount() {
            this.context.onIonViewWillEnter(() => {
                if (this.componentRef.current.ionViewWillEnter) {
                    this.componentRef.current.ionViewWillEnter();
                }
            });
            this.context.onIonViewDidEnter(() => {
                if (this.componentRef.current.ionViewDidEnter) {
                    this.componentRef.current.ionViewDidEnter();
                }
            });
            this.context.onIonViewWillLeave(() => {
                if (this.componentRef.current.ionViewWillLeave) {
                    this.componentRef.current.ionViewWillLeave();
                }
            });
            this.context.onIonViewDidLeave(() => {
                if (this.componentRef.current.ionViewDidLeave) {
                    this.componentRef.current.ionViewDidLeave();
                }
            });
        }
        render() {
            return (React.createElement(IonLifeCycleContext.Consumer, null, context => {
                this.context = context;
                return (React.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props)));
            }));
        }
    };
};

const useIonViewWillEnter = (callback) => {
    const value = useContext(IonLifeCycleContext);
    value.onIonViewWillEnter(callback);
};
const useIonViewDidEnter = (callback) => {
    const value = useContext(IonLifeCycleContext);
    value.onIonViewDidEnter(callback);
};
const useIonViewWillLeave = (callback) => {
    const value = useContext(IonLifeCycleContext);
    value.onIonViewWillLeave(callback);
};
const useIonViewDidLeave = (callback) => {
    const value = useContext(IonLifeCycleContext);
    value.onIonViewDidLeave(callback);
};

export { IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNote, IonPage, IonPicker, IonPickerColumn, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterLink, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSelectPopover, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, IonicContext, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, useIonicConfig, withIonLifeCycle };
