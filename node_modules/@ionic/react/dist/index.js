'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var loader = require('@ionic/core/loader');
var React = require('react');
var React__default = _interopDefault(React);
var tslib_1 = require('tslib');
var ReactDom = _interopDefault(require('react-dom'));
var reactCore = require('@ionic/react-core');
var core = require('@ionic/core');
var ionicons = require('ionicons');
var icons = require('ionicons/icons');

function attachEventProps(node, newProps, oldProps = {}) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className) {
        node.className = className;
    }
    Object.keys(newProps).forEach(name => {
        if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {
            return;
        }
        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
            const eventName = name.substring(2);
            const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
            if (!isCoveredByReact(eventNameLc)) {
                syncEvent(node, eventNameLc, newProps[name]);
            }
        }
        else {
            node[name] = newProps[name];
        }
    });
}
function getClassName(classList, newProps, oldProps) {
    // map the classes to Maps for performance
    const currentClasses = arrayToMap(classList);
    const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);
    const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);
    const finalClassNames = [];
    // loop through each of the current classes on the component
    // to see if it should be a part of the classNames added
    currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
            // add it as its already included in classnames coming in from newProps
            finalClassNames.push(currentClass);
            incomingPropClasses.delete(currentClass);
        }
        else if (!oldPropClasses.has(currentClass)) {
            // add it as it has NOT been removed by user
            finalClassNames.push(currentClass);
        }
    });
    incomingPropClasses.forEach(s => finalClassNames.push(s));
    return finalClassNames.join(' ');
}
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isCoveredByReact(eventNameSuffix, doc = document) {
    const eventName = 'on' + eventNameSuffix;
    let isSupported = eventName in doc;
    if (!isSupported) {
        const element = doc.createElement('div');
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] === 'function';
    }
    return isSupported;
}
function syncEvent(node, eventName, newEventHandler) {
    const eventStore = node.__events || (node.__events = {});
    const oldEventHandler = eventStore[eventName];
    // Remove old listener so they don't double up.
    if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
    }
    // Bind new listener.
    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
        newEventHandler.call(this, e);
    });
}
function arrayToMap(arr) {
    const map = new Map();
    arr.forEach((s) => map.set(s, s));
    return map;
}

const IonicContext = /*@__PURE__*/ React__default.createContext({
    getConfig: () => { },
    setConfig: () => { },
    platform: undefined
});

const useIonicConfig = () => {
    const value = React__default.useContext(IonicContext);
    const config = value.getConfig() || {};
    const hook = [config, value.setConfig];
    return hook;
};

const dashToPascalCase = (str) => str.toLowerCase().split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
function generateUniqueId() {
    return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {
        const random = crypto.getRandomValues(new Uint8Array(1));
        return (c ^ random[0] & 15 >> c / 4).toString(16);
    });
}

function createReactComponent(tagName, attributeValues = [], hrefComponent = false) {
    const displayName = dashToPascalCase(tagName);
    class ReactComponent extends React__default.Component {
        constructor(props) {
            super(props);
            this.handleClick = this.handleClick.bind(this);
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            this.componentWillReceiveProps(this.props);
        }
        componentWillReceiveProps(props) {
            const node = ReactDom.findDOMNode(this);
            attachEventProps(node, props, this.props);
        }
        handleClick(e) {
            const { href, target, routerDirection } = this.props;
            if ((href && this.context.hasIonicRouter()) && !target) {
                e.preventDefault();
                this.context.navigate(href, routerDirection);
            }
        }
        render() {
            const _a = this.props, { children, forwardedRef } = _a, cProps = tslib_1.__rest(_a, ["children", "forwardedRef"]);
            const propsWithoutAttributeValues = Object.keys(cProps).reduce((oldValue, key) => {
                if (attributeValues.indexOf(key) === -1) {
                    oldValue[key] = cProps[key];
                }
                return oldValue;
            }, {});
            const newProps = Object.assign({}, propsWithoutAttributeValues, { ref: forwardedRef });
            if (hrefComponent) {
                if (newProps.onClick) {
                    const oldClick = newProps.onClick;
                    newProps.onClick = (e) => {
                        oldClick(e);
                        if (!e.defaultPrevented) {
                            this.handleClick(e);
                        }
                    };
                }
                else {
                    newProps.onClick = this.handleClick;
                }
            }
            return React__default.createElement(tagName, newProps, children);
        }
    }
    ReactComponent.contextType = reactCore.NavContext;
    function forwardRef(props, ref) {
        return React__default.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    }
    forwardRef.displayName = displayName;
    return React__default.forwardRef(forwardRef);
}

// /*@__PURE__*/createReactComponent
const IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar');
const IonBackButtonInner = /*@__PURE__*/ createReactComponent('ion-back-button');
const IonAppInner = /*@__PURE__*/ createReactComponent('ion-app');

class Platform {
    constructor() { }
    /**
     * @returns returns true/false based on platform.
     * @description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.                      |
     * | mobile          | on a mobile device.                |
     * | mobileweb       | on a mobile device in a browser.   |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     */
    is(platformName) {
        return core.isPlatform(window, platformName);
    }
    /**
     * @returns the array of platforms
     * @description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     */
    platforms() {
        return core.getPlatforms(window);
    }
    /**
   * Returns if this app is using right-to-left language direction or not.
   * We recommend the app's `index.html` file already has the correct `dir`
   * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
   * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
   */
    get isRTL() {
        return document.dir === 'rtl';
    }
    /**
   * Get the query string parameter
   */
    getQueryParam(key) {
        return readQueryParam(window.location.href, key);
    }
    /**
     * Returns `true` if the app is in landscape mode.
     */
    isLandscape() {
        return !this.isPortrait();
    }
    /**
    * Returns `true` if the app is in portait mode.
    */
    isPortrait() {
        return window.matchMedia && window.matchMedia('(orientation: portrait)').matches;
    }
    testUserAgent(expression) {
        const nav = window.navigator;
        return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);
    }
    /**
   * Get the current url.
   */
    url() {
        return window.location.href;
    }
    /**
     * Gets the width of the platform's viewport using `window.innerWidth`.
     */
    width() {
        return window.innerWidth;
    }
    /**
     * Gets the height of the platform's viewport using `window.innerHeight`.
     */
    height() {
        return window.innerHeight;
    }
}
const readQueryParam = (url, key) => {
    key = key.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + key + '=([^&#]*)');
    const results = regex.exec(url);
    return results ? decodeURIComponent(results[1].replace(/\+/g, ' ')) : null;
};

function getConfig() {
    const coreConfig = getCoreConfig();
    const config = Array.from(coreConfig.m).reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
    }, {});
    return config;
}
function setConfig(config) {
    const coreConfig = getCoreConfig();
    coreConfig.reset(config);
}
function getCoreConfig() {
    if (typeof window !== 'undefined') {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
            return window.Ionic.config;
        }
    }
    return null;
}

class IonApp extends React__default.Component {
    constructor(props) {
        super(props);
        const ionicPlatform = new Platform();
        this.state = {
            getConfig: getConfig,
            setConfig: setConfig,
            platform: ionicPlatform
        };
    }
    render() {
        return (React__default.createElement(IonicContext.Provider, { value: this.state },
            React__default.createElement(IonAppInner, null, this.props.children)));
    }
}

// ionicons
const IonIcon = /*@__PURE__*/ createReactComponent('ion-icon', ['icon']);
// /*@__PURE__*/createReactComponent
const IonTab = /*@__PURE__*/ createReactComponent('ion-tab');
const IonTabButton = /*@__PURE__*/ createReactComponent('ion-tab-button');
const IonRouterLink = /*@__PURE__*/ createReactComponent('ion-router-link', [], true);
const IonAvatar = /*@__PURE__*/ createReactComponent('ion-avatar');
const IonBackdrop = /*@__PURE__*/ createReactComponent('ion-backdrop');
const IonBadge = /*@__PURE__*/ createReactComponent('ion-badge');
const IonButton = /*@__PURE__*/ createReactComponent('ion-button', [], true);
const IonButtons = /*@__PURE__*/ createReactComponent('ion-buttons');
const IonCard = /*@__PURE__*/ createReactComponent('ion-card', [], true);
const IonCardContent = /*@__PURE__*/ createReactComponent('ion-card-content');
const IonCardHeader = /*@__PURE__*/ createReactComponent('ion-card-header');
const IonCardSubtitle = /*@__PURE__*/ createReactComponent('ion-card-subtitle');
const IonCardTitle = /*@__PURE__*/ createReactComponent('ion-card-title');
const IonCheckbox = /*@__PURE__*/ createReactComponent('ion-checkbox');
const IonCol = /*@__PURE__*/ createReactComponent('ion-col');
const IonContent = /*@__PURE__*/ createReactComponent('ion-content');
const IonChip = /*@__PURE__*/ createReactComponent('ion-chip');
const IonDatetime = /*@__PURE__*/ createReactComponent('ion-datetime');
const IonFab = /*@__PURE__*/ createReactComponent('ion-fab');
const IonFabButton = /*@__PURE__*/ createReactComponent('ion-fab-button', [], true);
const IonFabList = /*@__PURE__*/ createReactComponent('ion-fab-list');
const IonFooter = /*@__PURE__*/ createReactComponent('ion-footer');
const IonGrid = /*@__PURE__*/ createReactComponent('ion-grid');
const IonHeader = /*@__PURE__*/ createReactComponent('ion-header');
const IonImg = /*@__PURE__*/ createReactComponent('ion-img');
const IonInfiniteScroll = /*@__PURE__*/ createReactComponent('ion-infinite-scroll');
const IonInput = /*@__PURE__*/ createReactComponent('ion-input');
const IonItem = /*@__PURE__*/ createReactComponent('ion-item', [], true);
const IonItemDivider = /*@__PURE__*/ createReactComponent('ion-item-divider');
const IonItemGroup = /*@__PURE__*/ createReactComponent('ion-item-group');
const IonItemOption = /*@__PURE__*/ createReactComponent('ion-item-option', [], true);
const IonItemOptions = /*@__PURE__*/ createReactComponent('ion-item-options');
const IonItemSliding = /*@__PURE__*/ createReactComponent('ion-item-sliding');
const IonLabel = /*@__PURE__*/ createReactComponent('ion-label');
const IonList = /*@__PURE__*/ createReactComponent('ion-list');
const IonListHeader = /*@__PURE__*/ createReactComponent('ion-list-header');
const IonMenu = /*@__PURE__*/ createReactComponent('ion-menu');
const IonMenuButton = /*@__PURE__*/ createReactComponent('ion-menu-button');
const IonMenuToggle = /*@__PURE__*/ createReactComponent('ion-menu-toggle');
const IonNote = /*@__PURE__*/ createReactComponent('ion-note');
const IonPicker = /*@__PURE__*/ createReactComponent('ion-picker');
const IonPickerColumn = /*@__PURE__*/ createReactComponent('ion-picker-column');
const IonNav = /*@__PURE__*/ createReactComponent('ion-nav');
const IonProgressBar = /*@__PURE__*/ createReactComponent('ion-progress-bar');
const IonRadio = /*@__PURE__*/ createReactComponent('ion-radio');
const IonRadioGroup = /*@__PURE__*/ createReactComponent('ion-radio-group');
const IonRange = /*@__PURE__*/ createReactComponent('ion-range');
const IonRefresher = /*@__PURE__*/ createReactComponent('ion-refresher');
const IonRefresherContent = /*@__PURE__*/ createReactComponent('ion-refresher-content');
const IonReorder = /*@__PURE__*/ createReactComponent('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ createReactComponent('ion-reorder-group');
const IonRippleEffect = /*@__PURE__*/ createReactComponent('ion-ripple-effect');
const IonRouterOutlet = /*@__PURE__*/ createReactComponent('ion-router-outlet');
const IonRow = /*@__PURE__*/ createReactComponent('ion-row');
const IonSearchbar = /*@__PURE__*/ createReactComponent('ion-searchbar');
const IonSegment = /*@__PURE__*/ createReactComponent('ion-segment');
const IonSegmentButton = /*@__PURE__*/ createReactComponent('ion-segment-button');
const IonSelect = /*@__PURE__*/ createReactComponent('ion-select');
const IonSelectOption = /*@__PURE__*/ createReactComponent('ion-select-option');
const IonSelectPopover = /*@__PURE__*/ createReactComponent('ion-select-popover');
const IonSkeletonText = /*@__PURE__*/ createReactComponent('ion-skeleton-text');
const IonSlide = /*@__PURE__*/ createReactComponent('ion-slide');
const IonSlides = /*@__PURE__*/ createReactComponent('ion-slides');
const IonSpinner = /*@__PURE__*/ createReactComponent('ion-spinner');
const IonSplitPane = /*@__PURE__*/ createReactComponent('ion-split-pane');
const IonText = /*@__PURE__*/ createReactComponent('ion-text');
const IonTextarea = /*@__PURE__*/ createReactComponent('ion-textarea');
const IonThumbnail = /*@__PURE__*/ createReactComponent('ion-thumbnail');
const IonTitle = /*@__PURE__*/ createReactComponent('ion-title');
const IonToggle = /*@__PURE__*/ createReactComponent('ion-toggle');
const IonToolbar = /*@__PURE__*/ createReactComponent('ion-toolbar');
const IonVirtualScroll = /*@__PURE__*/ createReactComponent('ion-virtual-scroll');

function createControllerComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactControllerComponent extends React__default.Component {
        constructor(props) {
            super(props);
            this.id = generateUniqueId();
        }
        static get displayName() {
            return displayName;
        }
        async componentDidMount() {
            const { isOpen } = this.props;
            if (isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { isOpen, onDidDismiss } = _a, cProps = tslib_1.__rest(_a, ["isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return null;
        }
    };
}

const IonAlert = /*@__PURE__*/ createControllerComponent('IonAlert', core.alertController);

const IonLoading = /*@__PURE__*/ createControllerComponent('IonLoading', core.loadingController);

const IonToast = /*@__PURE__*/ createControllerComponent('IonToast', core.toastController);

function createOverlayComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactOverlayComponent extends React__default.Component {
        constructor(props) {
            super(props);
            this.el = document.createElement('div');
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            if (this.props.isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { children, isOpen, onDidDismiss = () => { } } = _a, cProps = tslib_1.__rest(_a, ["children", "isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps, { component: this.el, componentProps: {} }));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return ReactDom.createPortal(this.props.children, this.el);
        }
    };
}

const IonActionSheet = /*@__PURE__*/ createOverlayComponent('IonActionSheet', core.actionSheetController);

const IonModal = /*@__PURE__*/ createOverlayComponent('IonModal', core.modalController);

const IonPopover = /*@__PURE__*/ createOverlayComponent('IonPopover', core.popoverController);

const IonPageInternal = (_a) => {
    var { children, forwardedRef, className } = _a, props = tslib_1.__rest(_a, ["children", "forwardedRef", "className"]);
    return (React__default.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));
};
function forwardRef(props, ref) {
    return React__default.createElement(IonPageInternal, Object.assign({}, props, { forwardedRef: ref }));
}
forwardRef.displayName = 'IonPage';
const IonPage = /*@__PURE__*/ React__default.forwardRef(forwardRef);

class IonTabBarUnwrapped extends React__default.Component {
    constructor(props) {
        super(props);
        this.onTabButtonClick = (e) => {
            const targetUrl = (this.state.activeTab === e.detail.tab) ?
                this.state.tabs[e.detail.tab].originalHref :
                this.state.tabs[e.detail.tab].currentHref;
            this.props.navigate(targetUrl);
        };
        this.renderChild = (activeTab) => (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                const href = (child.props.tab === activeTab) ? this.props.currentPath : (this.state.tabs[child.props.tab].currentHref);
                return React__default.cloneElement(child, {
                    href,
                    onIonTabButtonClick: this.onTabButtonClick
                });
            }
            return null;
        };
        const tabActiveUrls = {};
        React__default.Children.forEach(this.props.children, (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                tabActiveUrls[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href
                };
            }
        });
        this.state = {
            activeTab: null,
            tabs: tabActiveUrls
        };
    }
    static getDerivedStateFromProps(props, state) {
        const activeTab = Object.keys(state.tabs)
            .find(key => {
            const href = state.tabs[key].originalHref;
            return props.currentPath.startsWith(href);
        });
        if (!activeTab || (activeTab === state.activeTab && state.tabs[activeTab].currentHref === props.currentPath)) {
            return null;
        }
        return {
            activeTab,
            tabs: Object.assign({}, state.tabs, { [activeTab]: {
                    originalHref: state.tabs[activeTab].originalHref,
                    currentHref: props.currentPath
                } })
        };
    }
    render() {
        return (React__default.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: this.state.activeTab }), React__default.Children.map(this.props.children, this.renderChild(this.state.activeTab))));
    }
}
const IonTabBar = (props) => {
    const context = React.useContext(reactCore.NavContext);
    return (React__default.createElement(IonTabBarUnwrapped, Object.assign({}, props, { navigate: (path) => {
            context.navigate(path);
        }, currentPath: context.currentPath }), props.children));
};

const hostStyles = {
    display: 'flex',
    position: 'absolute',
    top: '0',
    left: '0',
    right: '0',
    bottom: '0',
    flexDirection: 'column',
    width: '100%',
    height: '100%',
    contain: 'layout size style'
};
const tabsInner = {
    position: 'relative',
    flex: 1,
    contain: 'layout size style'
};
class IonTabs extends React__default.Component {
    constructor(props) {
        super(props);
        this.routerOutletRef = React__default.createRef();
    }
    render() {
        let outlet;
        let tabBar;
        React__default.Children.forEach(this.props.children, (child) => {
            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {
                return;
            }
            if (child.type === IonRouterOutlet) {
                outlet = child;
            }
            if (child.type === IonTabBar) {
                tabBar = child;
            }
        });
        if (!outlet) {
            throw new Error('IonTabs must contain an IonRouterOutlet');
        }
        const NavManager = this.context.getViewManager();
        return (React__default.createElement("div", { style: hostStyles },
            tabBar.props.slot === 'top' ? tabBar : null,
            React__default.createElement("div", { style: tabsInner, className: "tabs-inner" }, this.context.hasIonicRouter() ? (React__default.createElement(NavManager, null, outlet)) : (React__default.createElement(React__default.Fragment, null, outlet))),
            tabBar.props.slot === 'bottom' ? tabBar : null));
    }
}
IonTabs.contextType = reactCore.NavContext;

class IonBackButton extends React__default.Component {
    constructor() {
        super(...arguments);
        this.clickButton = (e) => {
            if (this.context.hasIonicRouter()) {
                e.stopPropagation();
                this.context.goBack(this.props.defaultHref);
            }
            else {
                window.location.href = this.props.defaultHref;
            }
        };
    }
    render() {
        return (React__default.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props)));
    }
}
IonBackButton.contextType = reactCore.NavContext;

loader.defineCustomElements(window);
// Icons that are used by internal components
ionicons.addIcons({
    'ios-close': icons.close.ios,
    'md-close': icons.close.md,
    'ios-reorder': icons.reorder.ios,
    'md-reorder': icons.reorder.md,
    'ios-menu': icons.menu.ios,
    'md-menu': icons.menu.md,
    'ios-arrow-forward': icons.arrowForward.ios,
    'md-arrow-forward': icons.arrowForward.md,
    'ios-arrow-back': icons.arrowBack.ios,
    'md-arrow-back': icons.arrowBack.md,
    'ios-arrow-down': icons.arrowDown.ios,
    'md-arrow-down': icons.arrowDown.md,
    'ios-search': icons.search.ios,
    'md-search': icons.search.md,
    'ios-close-circle': icons.closeCircle.ios,
    'md-close-circle': icons.closeCircle.md,
});

const withIonLifeCycle = (WrappedComponent) => {
    return class IonLifeCycle extends React__default.Component {
        constructor(props) {
            super(props);
            this.componentRef = React__default.createRef();
        }
        componentDidMount() {
            this.context.onIonViewWillEnter(() => {
                if (this.componentRef.current.ionViewWillEnter) {
                    this.componentRef.current.ionViewWillEnter();
                }
            });
            this.context.onIonViewDidEnter(() => {
                if (this.componentRef.current.ionViewDidEnter) {
                    this.componentRef.current.ionViewDidEnter();
                }
            });
            this.context.onIonViewWillLeave(() => {
                if (this.componentRef.current.ionViewWillLeave) {
                    this.componentRef.current.ionViewWillLeave();
                }
            });
            this.context.onIonViewDidLeave(() => {
                if (this.componentRef.current.ionViewDidLeave) {
                    this.componentRef.current.ionViewDidLeave();
                }
            });
        }
        render() {
            return (React__default.createElement(reactCore.IonLifeCycleContext.Consumer, null, context => {
                this.context = context;
                return (React__default.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props)));
            }));
        }
    };
};

const useIonViewWillEnter = (callback) => {
    const value = React.useContext(reactCore.IonLifeCycleContext);
    value.onIonViewWillEnter(callback);
};
const useIonViewDidEnter = (callback) => {
    const value = React.useContext(reactCore.IonLifeCycleContext);
    value.onIonViewDidEnter(callback);
};
const useIonViewWillLeave = (callback) => {
    const value = React.useContext(reactCore.IonLifeCycleContext);
    value.onIonViewWillLeave(callback);
};
const useIonViewDidLeave = (callback) => {
    const value = React.useContext(reactCore.IonLifeCycleContext);
    value.onIonViewDidLeave(callback);
};

exports.IonActionSheet = IonActionSheet;
exports.IonAlert = IonAlert;
exports.IonApp = IonApp;
exports.IonAvatar = IonAvatar;
exports.IonBackButton = IonBackButton;
exports.IonBackdrop = IonBackdrop;
exports.IonBadge = IonBadge;
exports.IonButton = IonButton;
exports.IonButtons = IonButtons;
exports.IonCard = IonCard;
exports.IonCardContent = IonCardContent;
exports.IonCardHeader = IonCardHeader;
exports.IonCardSubtitle = IonCardSubtitle;
exports.IonCardTitle = IonCardTitle;
exports.IonCheckbox = IonCheckbox;
exports.IonChip = IonChip;
exports.IonCol = IonCol;
exports.IonContent = IonContent;
exports.IonDatetime = IonDatetime;
exports.IonFab = IonFab;
exports.IonFabButton = IonFabButton;
exports.IonFabList = IonFabList;
exports.IonFooter = IonFooter;
exports.IonGrid = IonGrid;
exports.IonHeader = IonHeader;
exports.IonIcon = IonIcon;
exports.IonImg = IonImg;
exports.IonInfiniteScroll = IonInfiniteScroll;
exports.IonInput = IonInput;
exports.IonItem = IonItem;
exports.IonItemDivider = IonItemDivider;
exports.IonItemGroup = IonItemGroup;
exports.IonItemOption = IonItemOption;
exports.IonItemOptions = IonItemOptions;
exports.IonItemSliding = IonItemSliding;
exports.IonLabel = IonLabel;
exports.IonList = IonList;
exports.IonListHeader = IonListHeader;
exports.IonLoading = IonLoading;
exports.IonMenu = IonMenu;
exports.IonMenuButton = IonMenuButton;
exports.IonMenuToggle = IonMenuToggle;
exports.IonModal = IonModal;
exports.IonNav = IonNav;
exports.IonNote = IonNote;
exports.IonPage = IonPage;
exports.IonPicker = IonPicker;
exports.IonPickerColumn = IonPickerColumn;
exports.IonPopover = IonPopover;
exports.IonProgressBar = IonProgressBar;
exports.IonRadio = IonRadio;
exports.IonRadioGroup = IonRadioGroup;
exports.IonRange = IonRange;
exports.IonRefresher = IonRefresher;
exports.IonRefresherContent = IonRefresherContent;
exports.IonReorder = IonReorder;
exports.IonReorderGroup = IonReorderGroup;
exports.IonRippleEffect = IonRippleEffect;
exports.IonRouterLink = IonRouterLink;
exports.IonRouterOutlet = IonRouterOutlet;
exports.IonRow = IonRow;
exports.IonSearchbar = IonSearchbar;
exports.IonSegment = IonSegment;
exports.IonSegmentButton = IonSegmentButton;
exports.IonSelect = IonSelect;
exports.IonSelectOption = IonSelectOption;
exports.IonSelectPopover = IonSelectPopover;
exports.IonSkeletonText = IonSkeletonText;
exports.IonSlide = IonSlide;
exports.IonSlides = IonSlides;
exports.IonSpinner = IonSpinner;
exports.IonSplitPane = IonSplitPane;
exports.IonTab = IonTab;
exports.IonTabBar = IonTabBar;
exports.IonTabButton = IonTabButton;
exports.IonTabs = IonTabs;
exports.IonText = IonText;
exports.IonTextarea = IonTextarea;
exports.IonThumbnail = IonThumbnail;
exports.IonTitle = IonTitle;
exports.IonToast = IonToast;
exports.IonToggle = IonToggle;
exports.IonToolbar = IonToolbar;
exports.IonVirtualScroll = IonVirtualScroll;
exports.IonicContext = IonicContext;
exports.useIonViewDidEnter = useIonViewDidEnter;
exports.useIonViewDidLeave = useIonViewDidLeave;
exports.useIonViewWillEnter = useIonViewWillEnter;
exports.useIonViewWillLeave = useIonViewWillLeave;
exports.useIonicConfig = useIonicConfig;
exports.withIonLifeCycle = withIonLifeCycle;
